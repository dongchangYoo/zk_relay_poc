import "utils/pack/u32/pack256.zok" as pack256
import "utils/pack/u32/nonStrictUnpack256.zok" as unpack256
import "utils/pack/u32/pack128.zok" as pack128
import "utils/pack/u32/unpack128.zok" as unpack128

import "hashes/sha256/1024bit.zok" as sha256for1024
import "hashes/sha256/512bit.zok" as sha256for512

import "./libs/pack_target.zok" as pack_target
import "./libs/update_target.zok" as update_target
import "./libs/to_big_endian256.zok" as to_big_endian256
import "./libs/to_big_endian32.zok" as to_big_endian32



// TODO
def validate_block_header(u32 expected_bits, u32[8] expected_prev_hash, u32[32] target_block) -> (u32[8]):
    u32[8] target_prev_hash = target_block[1..9]
    u32 target_bits = target_block[18]

    /* Check previous hash of target_block */
    assert(target_prev_hash[0] == expected_prev_hash[0])
    assert(target_prev_hash[1] == expected_prev_hash[1])
    assert(target_prev_hash[2] == expected_prev_hash[2])
    assert(target_prev_hash[3] == expected_prev_hash[3])
    assert(target_prev_hash[4] == expected_prev_hash[4])
    assert(target_prev_hash[5] == expected_prev_hash[5])
    assert(target_prev_hash[6] == expected_prev_hash[6])
    assert(target_prev_hash[7] == expected_prev_hash[7])

    /* Calculate hash of target_block */
    u32[8] intermediary_image = sha256for1024(target_block[0..8], target_block[8..16], target_block[16..24], target_block[24..32])
    u32[8] block_hash = sha256for512(intermediary_image, [2147483648, ...[0; 6], 256])

    /* Check bits of target_block */
    assert(expected_bits == target_bits)

    /* Check requirement of block hash */
    field target = pack_target(to_big_endian32(target_bits))
    assert(target > pack256(to_big_endian256(block_hash)))

    return block_hash


def main(field epoch_head_time_and_bits, field prev_hash, private u32[1][32] intermediate_blocks, field[5] final_block) -> (u32[8]):
    u32[4] tmp = unpack128(epoch_head_time_and_bits)
    u32 epoch_head_time = tmp[2]
    u32 epoch_head_bits = tmp[3]

    u32[8] packed_prev_hash = unpack256(prev_hash)
    u32[32] padded_final_block = [
        ...unpack128(final_block[0]),
        ...unpack128(final_block[1]),
        ...unpack128(final_block[2]),
        ...unpack128(final_block[3]),
        ...unpack128(final_block[4]),
        2147483648, ...[0; 10], 640
    ]

    // validate headers
    u32[8] block_hash = validate_block_header(epoch_head_bits, packed_prev_hash, intermediate_blocks[0])
    // ...
    // ...

    // validate final block header
    // u32 next_bits = u32_32_final_block[18]
    // u32[8] final_hash = validate_block_header(next_bits, block_hash, padded_final_block)
    // field final_block_hash = pack256(final_hash)

    // validate target
    //field simulated_target = update_target(epoch_head_time, epoch_head_bits, intermediate_blocks[0][17])

    // return final_block_hash //, simulated_target
    return block_hash