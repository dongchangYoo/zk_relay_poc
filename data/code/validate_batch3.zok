import "utils/casts/u32_to_bits.zok" as u32_to_bits
import "utils/casts/u32_from_bits.zok" as u32_from_bits
import "utils/casts/u32_8_to_bool_256.zok" as u32_8_to_bits
import "utils/casts/bool_256_to_u32_8.zok" as u32_8_from_bits

import "utils/pack/u32/pack128.zok" as pack32To128
import "utils/pack/u32/unpack128.zok" as unpack128to32
import "hashes/sha256/1024bit.zok" as sha256for1024
import "hashes/sha256/512bits.zok" as sha256for512


import "utils/pack/bool/pack128.zok" as pack1To128
import "utils/pack/bool/unpack128.zok" as unpack128To1



import "./libs/sha256only.zok" as sha256only
import "./libs/getHexLength.zok" as getHexLength
import "./libs/compute_merkle_root.zok" as compute_merkle_root

// TODO refactoring done
def toBigEndian(u32 value) -> (u32):
    bool[32] bits = u32_to_bits(value)
    return u32_from_bits([...bits[24..32],...bits[16..24],...bits[8..16],...bits[0..8]])

def toBigEndian(u32[8] value) -> (field[128]):
    bool[256] bits = u32_8_to_bits(value)

    return u32_8_from_bits([
       ...bits[248..256],
       ...bits[240..248],
       ...bits[232..240],
       ...bits[224..232],
       ...bits[216..224],
       ...bits[208..216],
       ...bits[200..208],
       ...bits[192..200],
       ...bits[184..192],
       ...bits[176..184],
       ...bits[168..176],
       ...bits[160..168],
       ...bits[152..160],
       ...bits[144..152],
       ...bits[136..144],
       ...bits[128..136]
       ...bits[120..128],
       ...bits[112..120],
       ...bits[104..112],
       ...bits[96..104],
       ...bits[88..96],
       ...bits[80..88],
       ...bits[72..80],
       ...bits[64..72],
       ...bits[56..64],
       ...bits[48..56],
       ...bits[40..48],
       ...bits[32..40],
       ...bits[24..32],
       ...bits[16..24],
       ...bits[8..16],
       ...bits[0..8]
   ])

def packMaxVariance(field length) -> (field):
    field result = 0
    result = if length ==  1 then pack128([0, 0, 0, 15]) else result fi
    result = if length ==  2 then pack128([0, 0, 0, 255]) else result fi
    result = if length ==  3 then pack128([0, 0, 0, 4095]) else result fi
    result = if length ==  4 then pack128([0, 0, 0, 65535]) else result fi
    result = if length ==  5 then pack128([0, 0, 0, 1048575]) else result fi
    result = if length ==  6 then pack128([0, 0, 0, 16777215]) else result fi
    result = if length ==  7 then pack128([0, 0, 0, 268435455]) else result fi
    result = if length ==  8 then pack128([0, 0, 0, 4294967295]) else result fi

    result = if length ==  9 then pack128([0, 0, 4294967295, 15]) else result fi
    result = if length == 10 then pack128([0, 0, 4294967295, 255]) else result fi
    result = if length == 11 then pack128([0, 0, 4294967295, 4095]) else result fi
    result = if length == 12 then pack128([0, 0, 4294967295, 65535]) else result fi
    result = if length == 13 then pack128([0, 0, 4294967295, 1048575]) else result fi
    result = if length == 14 then pack128([0, 0, 4294967295, 16777215]) else result fi
    result = if length == 15 then pack128([0, 0, 4294967295, 268435455]) else result fi
    result = if length == 16 then pack128([0, 0, [4294967295; 2]]) else result fi

    result = if length == 17 then pack128([0, [4294967295; 2], 15]) else result fi
    result = if length == 18 then pack128([0, [4294967295; 2], 255]) else result fi
    result = if length == 19 then pack128([0, [4294967295; 2], 4095]) else result fi
    result = if length == 20 then pack128([0, [4294967295; 2], 65535]) else result fi
    result = if length == 21 then pack128([0, [4294967295; 2], 1048575]) else result fi
    result = if length == 22 then pack128([0, [4294967295; 2], 16777215]) else result fi
    result = if length == 23 then pack128([0, [4294967295; 2], 268435455]) else result fi
    result = if length == 24 then pack128([0, [4294967295; 3]]) else result fi

    result = if length == 25 then pack128([[4294967295; 3], 15]) else result fi
    result = if length == 26 then pack128([[4294967295; 3], 255]) else result fi
    result = if length == 27 then pack128([[4294967295; 3], 4095]) else result fi
    result = if length == 28 then pack128([[4294967295; 3], 65535]) else result fi
    result = if length == 29 then pack128([[4294967295; 3], 1048575]) else result fi
    result = if length == 30 then pack128([[4294967295; 3], 16777215]) else result fi
    result = if length == 31 then pack128([[4294967295; 3], 268435455]) else result fi
    result = if length == 32 then pack128([4294967295; 4]) else result fi
return result

def packTarget(field[32] bits) -> (field):
    field result = \
    if pack128([...[0; 120], ...bits[0..8]]) == 23 then pack128([...[0; 72], ...bits[8..32], ...[0; 32]]) else \
      if pack128([...[0; 120], ...bits[0..8]]) == 24 then pack128([...[0; 64], ...bits[8..32], ...[0; 40]]) else \
        if pack128([...[0; 120], ...bits[0..8]]) == 25 then pack128([...[0; 56], ...bits[8..32], ...[0; 48]]) else \
          if pack128([...[0; 120], ...bits[0..8]]) == 26 then pack128([...[0; 48], ...bits[8..32], ...[0; 56]]) else \
            if pack128([...[0; 120], ...bits[0..8]]) == 27 then pack128([...[0; 40], ...bits[8..32], ...[0; 64]]) else \
              if pack128([...[0; 120], ...bits[0..8]]) == 28 then pack128([...[0; 32], ...bits[8..32], ...[0; 72]]) else \
                if pack128([...[0; 120], ...bits[0..8]]) == 29 then pack128([...[0; 24], ...bits[8..32], ...[0; 80]]) else \
                  if pack128([...[0; 120], ...bits[0..8]]) == 30 then pack128([...[0; 16], ...bits[8..32], ...[0; 88]]) else \
                    if pack128([...[0; 120], ...bits[0..8]]) == 31 then pack128([...[0; 8], ...bits[8..32], ...[0; 96]]) else \
                    pack128([0; 128]) fi \
                  fi \
                fi \
              fi \
            fi \
          fi \
        fi \
      fi \
    fi
return result

def get_bit_length_bits(field[24] bits) -> (field):
    field result = 0
    for field i in 0..24 do
        result = if (result == 0) && (bits[i] == 1) then 24-i else result fi
    endfor
return result

def get_hex_length_bits(field[24] bits) -> (field):
    field bit_length = get_bit_length_bits(bits)
    field result = 0
    result = if bit_length > 0 then 1 else result fi
    result = if bit_length > 4 then 2 else result fi
    result = if bit_length > 8 then 3 else result fi
    result = if bit_length > 12 then 4 else result fi
    result = if bit_length > 16 then 5 else result fi
    result = if bit_length > 20 then 6 else result fi
return result

// call with last field of block array
def validate_target(field epoch_head, field epoch_tail, field next_epoch_head) -> (field[2]):
    field[128] epoch_head_unpacked = unpack128(epoch_head)
    field[128] epoch_tail_unpacked = unpack128(epoch_tail)
    field[128] next_epoch_head_unpacked = unpack128(next_epoch_head)
    field time_head = pack128([...[0; 96], ...toBigEndian(epoch_head_unpacked[32..64])])
    field time_tail = pack128([...[0; 96], ...toBigEndian(epoch_tail_unpacked[32..64])])

    field current_target = packTarget(toBigEndian(epoch_head_unpacked[64..96]))
    field time_delta = time_tail - time_head
    field target_time_delta = 1209600 // 2016 * 600 (time interval of 10 minutes)

    field target = current_target * time_delta // target_time_delta

    field encoded_target = packTarget(toBigEndian(next_epoch_head_unpacked[64..96]))
    field encoded_target_extended = encoded_target * target_time_delta

    // The encoding of targets uses a floor function, the comparison of a calculated target may therefore fail
    // Therefore, a maximum variance is calculated that is one hex digit in the encoding
    field maxVariance = packMaxVariance(getHexLength(target)-get_hex_length_bits(toBigEndian(next_epoch_head_unpacked[64..88])))
    // int('ffff' + 10 * '00', 16) * 2016 * 600 = 95832923060582736897701037735936000
    target = if target > 95832923060582736897701037735936000 then 95832923060582736897701037735936000 else target fi
    field delta = target - encoded_target_extended
    delta = if target >= encoded_target_extended then delta else maxVariance + 1 fi
    field valid = if delta <= maxVariance then 1 else 0 fi
    //field valid = if (37202390668975264121251936602161152-81015268229227203625641762304819200) < 1267650600228229401496703205375 then 1 else 0 fi
return [valid, current_target]

def hash_block_header(field[5] preimage) -> (field[2]):
    field[128] a = unpack128(preimage[0])
    field[128] b = unpack128(preimage[1])
    field[128] c = unpack128(preimage[2])
    field[128] d = unpack128(preimage[3])
    field[128] e = unpack128(preimage[4])

    field[256] preimage1 = [...a, ...b]
    field[256] preimage2 = [...c, ...d]
    field[256] preimage3 = [...[...e, 1], ...[0; 127]]
    field[256] dummy = [...[0; 246], ...[1, 0, 1, 0, 0, 0, 0, 0, 0, 0]] //second array indicates length of preimage = 640bit

    field[256] intermediary = sha256for1024(preimage1, preimage2, preimage3, dummy)

    field[256] r = sha256only(intermediary)

    field res0 = pack128(r[0..128])
    field res1 = pack128(r[128..256])

return [res0, res1]


def validate_block_header(u32 reference_target, u32[8] prev_block_hash, u32[20] target_block) -> (field[257]):
    /*
    a = unpack128To32(target_block[0])
	b = unpack128To32(target_block[1])
	c = unpack128To32(target_block[2])
	d = unpack128To32(target_block[3])
	e = unpack128To32(target_block[4])
    */

    u32[8] encoded_prev_block_hash = target_block[1..9]
    assert(encoded_prev_block_hash[0] == prev_block_hash[0])
    assert(encoded_prev_block_hash[1] == prev_block_hash[1])
    assert(encoded_prev_block_hash[2] == prev_block_hash[2])
    assert(encoded_prev_block_hash[3] == prev_block_hash[3])
    assert(encoded_prev_block_hash[4] == prev_block_hash[4])
    assert(encoded_prev_block_hash[5] == prev_block_hash[5])
    assert(encoded_prev_block_hash[6] == prev_block_hash[6])
    assert(encoded_prev_block_hash[7] == prev_block_hash[7])

    u32 current_target = target[18]
    assert(reference_target == current_target)

    /* Calculate target block hash*/
    intermediary_image = sha256for1024(target_block[0..8], target_block[8..16], [...target_block[16..20], ...[0; 4], [0; 8])
    u32[8] block_hash = sha256for512(intermediary_image, [0; 8])

    /* Calculate target value*/
    field target = packTarget(toBigEndian(current_target))

    /* Check if block hash is less than or equals to target */
    assert(target > pack128(toBigEndian(block_hash))) // TODO start here!!!

return [valid, ...r]
// STATIC_CODE

def main(u32[4] first_block_epoch, u32[8] prev_block_hash, private u32[2][20] intermediate_blocks, u32[20] final_block) -> (field[7]):

    u32 reference_target = first_block_epoch[2]

    field result = 1
    field[257] block1 = validate_block_header(reference_target, prev_block_hash, intermediate_blocks[0])
    result = if block1[0] == 0 || result == 0 then 0 else 1 fi

    // loop start
    field[257] block2 = validate_block_header(reference_target, block1[1..257], intermediate_blocks[1])
    result = if block2[0] == 0 || result == 0 then 0 else 1 fi

    field[128] e = unpack128(final_block[4]) //TODO: Clean up, dirty mirty
    field[257] block3 = validate_block_header(pack128([...[0; 96], ...e[64..96]]), block2[1..257], final_block)
    result = if block3[0] == 0 || result == 0 then 0 else 1 fi

    field[2] target_is_valid = validate_target(first_block_epoch, intermediate_blocks[1][4], final_block[4])

    field[2] merkle_root = compute_merkle_root([block1[1..257],block2[1..257],block3[1..257]])
    field[2] final_block_hash = [pack128(block3[1..129]), pack128(block3[129..257])]

return [result, target_is_valid[0], ...final_block_hash, target_is_valid[1], ...merkle_root]
