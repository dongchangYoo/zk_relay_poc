import "utils/pack/u32/pack256.zok" as pack256
import "utils/pack/u32/pack128.zok" as pack128
import "utils/pack/u32/unpack128.zok" as unpack128
import "hashes/sha256/1024bit.zok" as sha256for1024
import "hashes/sha256/512bit.zok" as sha256for512

from "./libs/pack_target.zok" import pack_target
from "./libs/update_target.zok" import update_target
from "./libs/to_big_endian.zok" import u32_to_big_endian
from "./libs/to_big_endian.zok" import u32_8_to_big_endian


// TODO
def validate_block_header(u32 expected_bits, u32[8] expected_prev_hash, u32[32] target_block) -> (u32[8]):
    u32[8] target_prev_hash = target_block[1..9]
    u32 target_bits = target_block[18]

    /* Check previous hash of target_block */
    assert(target_prev_hash[0] == expected_prev_hash[0])
    assert(target_prev_hash[1] == expected_prev_hash[1])
    assert(target_prev_hash[2] == expected_prev_hash[2])
    assert(target_prev_hash[3] == expected_prev_hash[3])
    assert(target_prev_hash[4] == expected_prev_hash[4])
    assert(target_prev_hash[5] == expected_prev_hash[5])
    assert(target_prev_hash[6] == expected_prev_hash[6])
    assert(target_prev_hash[7] == expected_prev_hash[7])

    /* Calculate hash of target_block */
    u32[8] intermediary_image = sha256for1024(target_block[0..8], target_block[8..16], target_block[16..24], target_block[24..32])
    u32[8] block_hash = sha256for512(intermediary_image, [2147483648, ...[0; 6], 256])

    /* Check bits of target_block */
    assert(expected_bits == target_bits)

    /* Check requirement of block hash */
    field target = pack_target(u32_to_big_endian(target_bits))
    assert(target > pack256(u32_8_to_big_endian(block_hash)))

    return block_hash


def main(field epoch_head_time_and_bits, field[2] f2_prev_hash, private u32[1][32] intermediate_blocks, field[5] final_block) -> (field[2], field):
    u32[4] tmp = unpack128(epoch_head_time_and_bits)
    u32 epoch_head_time = tmp[2]
    u32 epoch_head_bits = tmp[3]

    u32[8] prev_hash = [...unpack128(f2_prev_hash[0]), ...unpack128(f2_prev_hash[1])]
    u32[32] u32_32_final_block = [
        ...unpack128(final_block[0]),
        ...unpack128(final_block[1]),
        ...unpack128(final_block[2]),
        ...unpack128(final_block[3]),
        ...unpack128(final_block[4]),
        2147483648, ...[0; 10], 640
    ]

    // validate headers
    prev_hash = validate_block_header(epoch_head_bits, prev_hash, intermediate_blocks[0])
    // ...
    // ...

    // validate final block header
    u32 next_bits = u32_32_final_block[18]
    u32[8] final_hash = validate_block_header(next_bits, prev_hash, u32_32_final_block)
    field[2] final_block_hash = [pack128(final_hash[0..4]), pack128(final_hash[4..8])]

    // validate target
    field simulated_target = update_target(epoch_head_time, epoch_head_bits, intermediate_blocks[0][17])

    return final_block_hash, simulated_target